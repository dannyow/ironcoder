//
//  PixureSystem.m
//  PixureTest
//
//  Created by Joseph Wardell on 3/30/07.
//  Copyright 2007 Old Jewel Software. All rights reserved.
//

#import "PixureSystem.h"
#import "PixurePopulation.h"

@interface PixureSystem (PRIVATE)

- (void)setupPopulation;

@end

#pragma mark -

@implementation PixureSystem

- (id)initWithImage:(NSImage*)inImage;
{
	if (self = [super init])
	{
		[self setImage:inImage];
		
		drawingLock = [[NSLock alloc] init];
	}
	return self;
}

- (void)dealloc;
{
	[image release];
	[population release];
	[drawingLock release];
	
	[super dealloc];
}




#pragma mark -
#pragma mark Private Accessors


- (PixurePopulation*)population;
{ 
	if (nil == population)
		population = [[PixurePopulation alloc] initWithSize:[[self image] size]];
	return [[population retain] autorelease]; 
}


- (void)setPopulation:(PixurePopulation*)inPopulation;
{
	if ([[self population] isEqualTo:inPopulation])
		return;

	[inPopulation retain];
	[population release];
	population = inPopulation;
}

- (PixureImage*)sourceImage;
{ 
	if (nil == image)
		image = [[PixureImage alloc] initWithImage:nil];
	return [[image retain] autorelease]; 
}


- (void)setSourceImage:(PixureImage*)inPixureImage;
{
	if ([[self image] isEqualTo:inPixureImage])
		return;

	[inPixureImage retain];
	[image release];
	image = inPixureImage;

	[self setupPopulation];
//	[self setPopulation:[[[PixurePopulation alloc] initWithSize:[image size]] autorelease]];
//	[[self population] seedPopulationForFirstTime];
}


#pragma mark -
#pragma mark Genetic Algorithm

- (void)setupPopulation
{
	[self setPopulation:[[[PixurePopulation alloc] initWithSize:[image size]] autorelease]];
	[[self population] seedPopulationForFirstTime];
	generationCount = 0;
}

#pragma mark -
#pragma mark Accessors

// source image accessors
- (NSImage*)image;
{
	return [[self sourceImage] image];
}

- (void)setImage:(NSImage*)inImage;
{
	[[self sourceImage] setImage:inImage];

	[self setupPopulation];
	
	
//	[self setPopulation:[[[PixurePopulation alloc] initWithSize:[image size]] autorelease]];
//	[[self population] seedPopulationForFirstTime];
}

// return the number of generations passed
- (unsigned int) generationCount;
{
	return generationCount;
}

// return the image generated by the population of pixures
- (NSImage*)generatedImage;
{	
	// this lock lets updating the image displayed be one fluid action, instead of it having to wait for the background thread to finish its piddly accesses
	[drawingLock lock];
	NSImage* outImage = [[self population] image];
	[drawingLock unlock];
	
	return outImage;
}

// advance the population one generation
// this is the meat of the genetic algorithm
- (void)advanceOneGeneration;
{
	// this lock lets updating the image displayed be one fluid action, instead of it having to wait for the background thread to finish its piddly accesses
	[drawingLock lock];

//	unsigned int i;	for (i = 0; i < 1000; i++) 
//	{
		[[self population] cycleOnePixureInSystem:self];
//	}
	generationCount++;

	[drawingLock unlock];

/*	unsigned int numberOfLostPixures = [[self population] selectPixuresForSystem:self];
	BOOL lastGenerationSurvived = (numberOfLostPixures < 50);
	[[self population] breedNewPixuresForSystem:self];
//	[[self population] createNewPixuresForEmptyCoordinates];

	generationCount++;
	
	if (lastGenerationSurvived || 
		numberOfLostPixures > lastPopulationLoss)	// if the number of lost pixures has increaed, then we need to cull more to get more opportunity for growth
		[self _reduceTolerance];
		
	lastPopulationLoss = numberOfLostPixures;*/
}

// advance the population several generations
// this is the meat of the genetic algorithm
- (void)advanceGenerations:(unsigned int)inGenerationCount;
{
	// an inner autorelease pool to avoid loading up lots of ram
	NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
	unsigned int i;
	for (i = 0; i < inGenerationCount; i++) 
	{
		[self advanceOneGeneration];
	}
	[pool release];
}



//- (float)tolerance;
//{
//	return tolerance;
//}
//
//- (void)setTolerance:(float)inTolerance;
//{
//	if ([self tolerance] == inTolerance)
//		return;
//
//	tolerance = inTolerance;
//}
//
//- (void)_reduceTolerance;
//{
//	[self setTolerance:[self tolerance] * 0.9];
//}

- (unsigned int)numberOfRows;
{
	return [[self population] numberOfRows];
}

- (unsigned int)numberOfColumns;
{
	return [[self population] numberOfColumns];
}

- (unsigned int)numberOfPixures;
{
	return [[self population] numberOfPixures];
}

@end
